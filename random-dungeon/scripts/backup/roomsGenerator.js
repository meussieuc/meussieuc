var mazeGeneratorScriptLoaded = true;// Check for scripts dependenciesif (typeof(gridScriptLoaded) == "undefined") { console.error("grid.js include is missing before grid.js include"); }if (typeof(cellScriptLoaded) == "undefined") { console.error("cell.js include is missing before grid.js include"); }if (typeof(mainScriptLoaded) == "undefined") { console.error("main.js include is missing before grid.js include"); }// -----------------------------------------------------------------------------// MazeGenerator Class// -----------------------------------------------------------------------------class MazeGenerator {	// -----------	// constructor	// -----------   constructor(roomRoomProb, roomCorridorRoomProb) {		if (roomRoomProb + roomCorridorRoomProb != 1)         throw "Sum of probs must be equals to 1";				this.roomRoomProb         = roomRoomProb;		this.roomCorridorRoomProb = roomCorridorRoomProb;		      // Array of { seedNr, available, cell }      this.cells = new Array();      		// ---------------		// Private methods		// ---------------		// initGen		// -------      this.initGen = function() {            }            // genRoomRoom      // -----------      this.genRoomRoom = function(grid) {         var startingRoom  = getRandomRoom();         var door          = startingRoom.getRandomDoor();         var newRoomWidth  = getRandomInt(this.minRoomWidth,  this.maxRoomWidth);         var newRoomHeight = getRandomInt(this.minRoomHeight, this.maxRoomHeight);         var roomOffset    = getRandomInt(0, (door.Direction.Y == -1 ? ));               }      		// createNewCorridor		// -----------------      this.createNewCorridor = function(grid) {         var availableCells = Enumerable.From(this.cells).Where(function(c) { return c.available }).ToArray();         var startingSeedCell = availableCells[getRandomInt(0, availableCells.length - 1)];                  var startingSeedNr = startingSeedCell.seedNr;         var startingCell   = startingSeedCell.cell;                  var availableDirections = new Array();                  if (startingCell.Y > 0 && this.getSeedNrAt(startingCell.X, startingCell.Y - 1) != startingSeedNr)            availableDirections.push({ "dX": 0, "dY": -1 });         if (startingCell.Y < grid.Height - 1 && this.getSeedNrAt(startingCell.X, startingCell.Y + 1) != startingSeedNr)            availableDirections.push({ "dX": 0, "dY": 1 });         if (startingCell.X > 0 && this.getSeedNrAt(startingCell.X - 1, startingCell.Y) != startingSeedNr)            availableDirections.push({ "dX": -1, "dY": 0 });         if (startingCell.X < grid.Width - 1 && this.getSeedNrAt(startingCell.X + 1, startingCell.Y) != startingSeedNr)            availableDirections.push({ "dX": 1, "dY": 0 });                  if (availableDirections.length == 0) {            startingSeedCell.available = false;            return;         }                     var direction      = getRandomElement(availableDirections);         var maxLength      = getRandomInt(this.corridorMinLength, this.corridorMaxLength);         var corridorLength = 0;         var x              = startingCell.X;         var y              = startingCell.Y;         var cell           = startingCell;                  while (corridorLength < maxLength) {            // Move to the chosen direction            x = x + direction.dX;            y = y + direction.dY;                        // check if we hit the grid borders (stop here if so)            if (x < 0 || x >= grid.Width || y < 0 || y >= grid.Height)               return;                        // check if it hits an other cell            var targetCell = grid.at(x, y);                        if (targetCell !== null) {               var targetSeed = this.getSeedNrAt(x, y);                              if (targetSeed == startingSeedNr) {                  // hit the same seed: Stop here                  return;               }               else {                  // hit another seed: Merge them and then stop here                  if (direction.dY == -1)                     cell.North = null;                  if (direction.dY == 1)                     cell.South = null;                  if (direction.dX == -1)                     cell.West = null;                  if (direction.dX == 1)                     cell.East = null;                                    this.mergeSeeds(startingSeedNr, targetSeed);                                    return;               }            }                        // No hit: We create a new cell at that position            cell = grid.createCellAt(x, y);                        // Surround the cell by walls            cell.North = cell.South = cell.West = cell.East = "wall";                        // Remove the wall from where we came from            if (direction.dY == -1)               cell.South = null;            if (direction.dY == 1)               cell.North = null;            if (direction.dX == -1)               cell.East = null;            if (direction.dX == 1)               cell.West = null;                           this.cells.push({ "seedNr": startingSeedNr, "available": true, "cell": cell });                        corridorLength++;         }      }      		// mergeSeeds		// ----------      this.mergeSeeds = function(seedNr1, seedNb2) {         var seedNrToKeep   = Math.min(seedNr1, seedNb2);         var seedNrToChange = Math.max(seedNr1, seedNb2);                  for (var i in this.cells) {            if (this.cells[i].seedNr == seedNrToChange)               this.cells[i].seedNr = seedNrToKeep;         }      }      		// getSeedNrAt		// -----------      this.getSeedNrAt = function(x, y) {         var seedAndCell = this.getSeedAndCellAt(x, y);         return seedAndCell === null ? null : seedAndCell.seedNr;      }      		// getSeedAndCellAt		// ----------------      this.getSeedAndCellAt = function(x, y) {         return Enumerable.From(this.cells)            .Where(function(c) { return c.cell.X == x && c.cell.Y == y })            .FirstOrDefault(null);      }   }	   // ---------	// Accessors	// ---------	// NbSeeds	// -------   get NbSeeds() {      return Enumerable.From(this.cells).Distinct(function(c) { return c.seedNr }).Count();   }   	// ----------------	// Method overrides	// ----------------	// toString	// --------   toString() {      var string = "MazeGenerator { ";      var ownPropertyIndex = 0;            for (var propertyName in this) {         var propertyType = typeof(this[propertyName]);         if (!this.hasOwnProperty(propertyName) || propertyType == "function")            continue;                     if (ownPropertyIndex > 0)            string = string + ", ";                  string = string + propertyName + ": " + this[propertyName];                  ownPropertyIndex++;      }            string = string + " }";            return string;   }   	// -------------	// Public method	// -------------	// generate	// --------   generate(grid, stopCondition) {      var width       = grid.Width;      var height      = grid.Height;      var i           = 0;            this.initGen();            while (!stopCondition(i, this.cells.length, width * height, this.NbSeeds)) {         var roomRoom = getRandomBool(this.roomRoomProb);                  if (roomRoom) {            this.genRoomRoom(grid);         }         else {            this.genRoomCorridorRoom(grid);         }                  i++;      }      console.log("Generation done! (nbr iterations: " + i + ")");   }}