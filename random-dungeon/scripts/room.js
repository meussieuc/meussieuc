// -----------------------------------------------------------------------------// Room Class// -----------------------------------------------------------------------------class Room extends DungeonPart {	// -----------	// constructor	// -----------   constructor(pos, width, height, seedNr, grid) {      super(pos, grid);               if (width < 1)         throw new Error("Room width must be at least 1");               if (height < 1)         throw new Error("Room height must be at least 1");      		// ---------------		// Private members		// ---------------      this.width  = width;      this.height = height;      this.cells  = new Array();            // ---------------      // Private methods      // ---------------      // adjustCellBorders      // ------------------      this.adjustCellBorders = function(cell) {         for (var i in cell.Directions)            cell.Directions[i].Border = (this.containsCoord(cell.Directions[i].Destination)                                           ? null                                           : "wall");      }            // createCells      // -----------      this.createCells = function(grid, seedNr) {         var startCorner = this.pos;         var endCorner   = this.pos.plus(new Vector(this.width - 1, this.height - 1));                  for (var x = startCorner.X; x <= endCorner.X; x++) {            this.cells[x] = new Array();                        for (var y = startCorner.Y; y <= endCorner.Y; y++) {               var cell = grid.createCellAt(x, y, this);               cell.SeedNr = seedNr;               this.adjustCellBorders(cell);               this.cells[x][y] = cell;            }         }      }            // Create the cells constituing the room      this.createCells(grid, seedNr);   }		// ---------	// Accessors	// ---------   // Width   // -----   get Width() { return this.width; }   // Height   // ------   get Height() { return this.height; }   // SeedNr   // ------   get SeedNr() { return this.cells[0].seedNr; }   // MinCorner   // ---------   get MinCorner() { return this.Pos; }   // MaxCorner   // ---------   get MaxCorner() { return this.Pos.plus(new Vector(this.Width - 1, this.Height - 1)); }   	// ----------------	// Method overrides	// ----------------   	// --------------	// Public methods	// --------------      // getBestFit   // ----------   static getBestFit(grid, desiredPos, desiredWidth, desiredHeight, anchor) {      // Try to fit the room on the grid       // by leaving the anchor point inside of it       // and by maximizing the room area      // The closer to the original pos, the better.            // First of all, try to fit the room at the desired position      var pos            = desiredPos;      var overallBestFit = Room.getBestSizeFit(grid, pos, desiredWidth, desiredHeight, anchor);      overallBestFit.pos = pos;            // Move the position in a spiral way starting north to find the best fit      var dir                      = new Vector(0,-1);      var branchLength             = 1;      var branchLengthTraveled     = 0;      var lastFiveTurns            = new Array();      var lastFiveBranchesExceeded = false;            // Keep spiraling away until we made five turns that exceeded      while (!lastFiveBranchesExceeded) {         // Compute the next position on the spiral         pos = pos.plus(dir);         branchLengthTraveled++;                  // Get the best size fit at that position         var bestFit = Room.getBestSizeFit(grid, pos, desiredWidth, desiredHeight, anchor);                  // Check if we need to turn for the next step         if (branchLengthTraveled >= branchLength) {            // Make the next turn            dir = dir.getClockwise();                        if (lastFiveTurns.length >= 5)               lastFiveTurns.shift();                           lastFiveTurns.push({                branchLengthBefore: branchLength,               branchExceeds:           true            });                        // Extend next branches length after two consecutive same length branches            if (lastFiveTurns.length > 1                && lastFiveTurns[lastFiveTurns.length - 1].branchLengthBefore                == lastFiveTurns[lastFiveTurns.length - 2].branchLengthBefore)               branchLength++;                           branchLengthTraveled = 0;         }                     // Keep only the best fit of all (maximum area)         if (bestFit.area > overallBestFit.area) {            overallBestFit     = bestFit;            overallBestFit.pos = pos;         }                  if (!bestFit.exceeds)            lastFiveTurns[lastFiveTurns.length - 1].branchExceeds = false;                     lastFiveBranchesExceeded = lastFiveTurns.length >= 5             && !lastFiveTurns.some(function(t) { return !t.branchExceeds });      }            return overallBestFit;   }         // getBestSizeFit   // --------------   static getBestSizeFit(grid, pos, desiredWidth, desiredHeight, anchor) {      // Try to fit the room on the grid       // by leaving the anchor point inside of it       // and by maximizing the room area without moving it      var rectangle = new Rectangle(pos, desiredWidth, desiredHeight);      var bestSizeFit = {          exceeds: true,          area:   0,           width:  0,          height: 0       };            for (var width = desiredWidth; width > 0; width--) {         for (var height = desiredHeight; height > 0; height--) {            rectangle.Width  = width;            rectangle.Height = height;                        if (!rectangle.containsCoords(anchor) || rectangle.Area <= bestSizeFit.area)               break;                        if (grid.canFit(rectangle))               bestSizeFit = {                   exceeds: false,                   area:   rectangle.Area,                   width:  rectangle.Width,                   height: rectangle.Height                };         }      }            return bestSizeFit;   }      // containsCoord   // -------------   containsCoord(coord) {      var startCorner = this.pos;      var endCorner   = this.pos.plus(new Vector(this.width - 1, this.height - 1));            return coord.X >= startCorner.X          && coord.Y >= startCorner.Y          && coord.X <= endCorner.X           && coord.Y <= endCorner.Y ;   }      // getAvailableCells   // -----------------   getAvailableCells() {      var availableCells = new Array();            for (var x in this.cells)         for (var y in this.cells[x])            if (this.cells[x][y].Available)               availableCells.push(this.cells[x][y]);            return availableCells;   }      addWindowAtDirection(cellDirection, onlyTowardsOutdoor, windowProb) {      if (!getRandomBool(windowProb))         return;               if (cellDirection.Border != "wall")         return;               if (onlyTowardsOutdoor && cellDirection.DestinationCell !== null)         return;            cellDirection.Border = "window";   }      // addRandomWindows   // ----------------   addRandomWindows(onlyTowardsOutdoor, windowProb) {      if (windowProb === 0)         return;            var dir             = null;      var nextWindowCoord = null;      var period          = 1 / windowProb;      var addWindow       = 0;            for (var x in this.cells) {         if (nextWindowCoord === null)            nextWindowCoord = Number(x) + 1;                  if (Number(x) >= nextWindowCoord) {            addWindow = 1;            nextWindowCoord += period;         }         else            addWindow = 0;                  this.addWindowAtDirection(this.cells[x].first().getDirection(0,-1),                                    onlyTowardsOutdoor,                                    addWindow);                                            this.addWindowAtDirection(this.cells[x].last().getDirection(0,1),                                    onlyTowardsOutdoor,                                    addWindow);      }            nextWindowCoord = null;      var firstColumn = this.cells.first();      for (var y in firstColumn) {         if (nextWindowCoord === null)            nextWindowCoord = Number(y) + 1;                  if (Number(y) >= nextWindowCoord) {            addWindow = 1;            nextWindowCoord += period;         }         else            addWindow = 0;                  this.addWindowAtDirection(firstColumn[y].getDirection(-1,0),                                    onlyTowardsOutdoor,                                    addWindow);               }            nextWindowCoord = null;      var lastColumn = this.cells.last();      for (var y in lastColumn) {         if (nextWindowCoord === null)            nextWindowCoord = Number(y) + 1;                  if (Number(y) >= nextWindowCoord) {            addWindow = 1;            nextWindowCoord += period;         }         else            addWindow = 0;                  this.addWindowAtDirection(lastColumn[y].getDirection(1,0),                                    onlyTowardsOutdoor,                                    addWindow);               }   }   // addRandomWindows(onlyTowardsOutdoor, windowProb) {      // var dir       = null;      // var addWindow = false;            // for (var x in this.cells) {         // this.addWindowAtDirection(this.cells[x].first().getDirection(0,-1),                                    // onlyTowardsOutdoor,                                    // windowProb);                                            // this.addWindowAtDirection(this.cells[x].last().getDirection(0,1),                                    // onlyTowardsOutdoor,                                    // windowProb);      // }            // var firstColumn = this.cells.first();      // for (var y in firstColumn)         // this.addWindowAtDirection(firstColumn[y].getDirection(-1,0),                                    // onlyTowardsOutdoor,                                    // windowProb);            // var lastColumn = this.cells.last();      // for (var y in lastColumn)         // this.addWindowAtDirection(lastColumn[y].getDirection(1,0),                                    // onlyTowardsOutdoor,                                    // windowProb);   // }}