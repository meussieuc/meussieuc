// -----------------------------------------------------------------------------// MazeGenerator Class// -----------------------------------------------------------------------------class MazeGenerator extends BaseGenerator {	// -----------	// constructor	// -----------   constructor(newSeedProb, corridorMinLength, corridorMaxLength) {      super();               if (newSeedProb < 0 || newSeedProb > 1)         throw new Error("New seed probability must be between 0 and 1");      		// ---------------		// Private members		// ---------------      this.newSeedProb       = newSeedProb;      this.corridorMinLength = corridorMinLength;      this.corridorMaxLength = corridorMaxLength;      		// ---------------		// Private methods		// ---------------		// initGen		// -------      this.initGen = function() {            }      		// getAvailableCoords		// ------------------      this.getAvailableCoords = function(grid, maxTries) {         return getRandomElement(grid.EmptyCoords);      }            // createNewCorridor		// -----------------      this.createNewCorridor = function(grid, pos, direction, seedNr, startingBorder, endingBorder) {         // Create a new 1 length corridor at that position         var corridor = grid.createCorridor(pos, direction, 1, seedNr, startingBorder, endingBorder);                  // Expand the corridor to a random length         var res = corridor.expandTo(getRandomInt(this.corridorMinLength, this.corridorMaxLength));                  if (!res.hit || res.hitGridLimit) // No hit: Stop here            return;                     if (res.cellHit === null)            throw new Error("Unexpected corridor expand result");                  if (res.cellHit.SeedNr == corridor.SeedNr) // Hit same seed: Stop here            return;                     // Hit another seed, merge both seeds         // corridor.EndingBorder = null;         corridor.EndingBorder = res.cellHit.ParentDungeonPart instanceof Room ? "door" : null;         corridor.SeedNr = grid.mergeSeeds(res.cellHit.SeedNr, corridor.SeedNr);      }            // createNewSeed		// -------------      this.createNewSeed = function(grid) {         // Get a random available position         var pos = this.getAvailableCoords(grid, 20);                  if (pos === null)            return null;                     // Choose a random available direction at this position         // and set the seed number and corridor endings         var direction      = getRandomElement(grid.getAvailableDirectionsAt(pos));         var seedNr         = grid.getNewSeedNr();         var startingBorder = "wall";         var endingBorder   = "wall";                  // Create the corridor         this.createNewCorridor(grid, pos, direction, seedNr, startingBorder, endingBorder);                  this.createdSeedsCount++;      }            // expandRandomSeed		// ----------------      this.expandRandomSeed = function(grid, availableCells) {         // Choose a random cell from the available list from where to start the corridor         var startingCell = availableCells[getRandomInt(0, availableCells.length - 1)];                  // Check the available directions on this cell         var availableDirections = startingCell.AvailableDirections;                  if (availableDirections.length == 0)            return;                     // Choose a random direction,         // set starting position where it points         // and set the seed number and corridor endings         var direction      = getRandomElement(availableDirections);         var pos            = startingCell.Pos.plus(direction);         var seedNr         = startingCell.SeedNr;         // var startingBorder = null;         var startingBorder = startingCell.ParentDungeonPart instanceof Room ? "door" : null;         var endingBorder   = "wall";                  if (direction.DestinationCell === null) {            // Create the corridor            this.createNewCorridor(grid, pos, direction, seedNr, startingBorder, endingBorder);         }         else {            // direction.Border = null;            direction.Border = direction.DestinationCell.ParentDungeonPart instanceof Room ? "door" : null;            grid.mergeSeeds(startingCell.SeedNr, direction.DestinationCell.SeedNr);         }      }   }	   // ---------	// Accessors	// ---------   	// ----------------	// Method overrides	// ----------------	// toString	// --------   toString() {      return super.toString(true, false);   }   	// -------------	// Public method	// -------------	// generate	// --------   generate(grid, stopCheck, stopParams) {      this.initGen();            var i = 0;            while (!stopCheck(this.getGenState(grid, i), stopParams)) {         var newSeed = (grid.CellsCount == 0 || getRandomBool(this.newSeedProb));                  var availableCells = grid.AvailableCells;                  if (availableCells.length == 0 && i > 0) {            // This should never occur            console.error("Generation stopped before getting to the stop condition");            break;         }                   if (newSeed)            this.createNewSeed(grid);         else            this.expandRandomSeed(grid, availableCells);                  if (i % 100 == 0 && typeof postMessage === "function")            postMessage({                status: "generating",                renderedGrid: grid.renderHTML(40, 40, false),                htmlGridWidth: grid.Width * 40 + 10,               htmlGridHeight: grid.Height * 40 +10            });                  i++;      }      console.log("Generation done! (nbr iterations: " + i + ")");   }}